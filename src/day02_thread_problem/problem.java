package day02_thread_problem;


/**
 * 活跃性问题
 *      死锁 : 两个或多个线程永久阻塞，互相等待对方释放资源。
 *
 *      饥饿琐:
 *          优先级低的线程一直不能够被运行,活活被饿死
 *          高优先级吞噬所有低优先级的CPU时间片
 *          线程被永久堵塞在一个等待进入同步块的状态
 *          等待的线程永远不被唤醒
 *
 *          如何避免:
 *              设置合理的优先级
 *              使用琐代替synchronized, 来保证线程不会被永久的堵塞在一个等待进入的同步块
 *
 *      活锁:
 *          一个线程通常会有会响应其他线程的活动。
 *          如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。
 *          同死锁一样，发生活锁的线程无法继续执行。
 *          然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。
 */

/**
 * 性能问题
 *      时间片由CPU分配给线程/进程, 每个时间片执行的时间结束,就会切换(需要记录上一次运行的记录),切换就会浪费资源
 *      所以性能不一定快
 */
