# 活跃性问题
> `死锁` 
>
>       两个或多个线程永久阻塞，互相等待对方释放资源。

> `饥饿琐`（见live中案例）
>
>       1.优先级低的线程一直不能够被运行,活活被饿死 
>       2.高优先级吞噬所有低优先级的CPU时间片
>       3.线程被永久堵塞在一个等待进入同步块的状态 等待的线程永远不被唤醒
>
>         如何避免:
>             1.设置合理的优先级
>             2.使用琐代替synchronized, 来保证线程不会被永久的堵塞在一个等待进入的同步块

> `活锁` 
>
>       1.一个线程通常会有会响应其他线程的活动。
>       2.如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。
>       3.同死锁一样，发生活锁的线程无法继续执行。
>       4.然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。

> `性能问题` 
>
>       1.时间片由CPU分配给线程/进程,
>       每个时间片执行的时间结束,就会切换(需要记录上一次运行的记录),切换就会浪费资源所以性能不一定快

# 安全性问题
> `访问共享资源`
>
>       共享资源被多个线程访问，如果不加锁，会导致资源数据混乱
>       初始 a = 1;
>       线程1 执行 a = a + 1;
>       java虚拟机相当于执行 1 + 1；然后执行a = 2;
>       如果线程1执行到 1 + 1；的时候，线程2也去读a,此时a的值是1，然后执行1 + 1;a = 2;
>       这时到线程1执行a = 2;此时a连续加了两次，却值还是2，造成安全性问题
> 发生场景
> * 多线程共享资源 
> * 对资源进行非原子性操作(对应字节码中非一条运行就结束的操作) 
>
> 解决方案（加锁） 
> * synchronized 保证了在多线程共享资源时，对资源操作的原子性,但是一定要确认是给哪个对象加上了锁，是实例对象，还是当前的class对象，这很容易造成错误
>
>  * synchronized 修饰实例方法，锁定当前实例对象（见代码safe02）
>
>  * synchronized 修饰静态方法，锁定当前类的class文件（见代码safe03）
>
>  * synchronized 指定锁对象（见代码safe04）
>
>  * 原理
>
>      * 内置琐
>           
>               任何对象都可以作为琐, 那么琐信息存在对象的什么地方?
>                   存在对象头中
>               对象头中的信息
>                   Mark Word(Hash 和 锁信息(线程id Epoch  对象的分代年龄信息  是否是偏向琐  琐标志位) 等....)
>                   Class Metadata Address(类的对象的地址)
>                   Array Length
>      * 偏向琐
>
>            在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。
>            偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，
>            当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。
>            所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。
>            但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，
>            需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
>      * 轻量级琐
>
>            倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word的结构也变为轻量级锁的结构。
>            轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。
>            需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
>      * 自旋锁
>
>            轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
>            这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，
>            毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，
>            因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机 会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，
>            一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。
>            如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。
>      * 锁消除
>
>            消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，
>            通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，
>            如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，
>            因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。
>            消除StringBuffer同步锁
>            public class StringBufferRemoveSync {
>                public void add(String str1, String str2) {
>                    //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用
>                    //因此sb属于不可能共享的资源,JVM会自动消除内部的锁
>                    StringBuffer sb = new StringBuffer();
>                    sb.append(str1).append(str2);
>                }
>                public static void main(String[] args) {
>                    StringBufferRemoveSync rmsync = new StringBufferRemoveSync();
>                    for (int i = 0; i < 10000000; i++) {
>                        rmsync.add("abc", "123");
>                    }
>                }
>            }
>
>      * 重量级琐
>
> * Volatile
>  * * volatile 称之为轻量级锁，被volatile修饰的变量在线程之间是可见的，也就是说一个线程修改了这个变量的值，在另外一个线程中能够读到这个修改后的值
>  * * Synchronized除了线程之间互斥，还有一个作用就是可见性
>  * * 其实volatile关键字其实就相当于汇编中的lock指令
>  * * 将当前处理器的缓存的内容写回到系统内存中，然后使其他CPU里之前缓存的数据失效
>  * * volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。
>
> * 和Synchronized的区别
> 
>       1.synchronized关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。
>         更重要的是，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。
>       2.volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。
>       3.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
>       4.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
>       5.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
>       6.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
>       7.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
>
> * Atomic
>  * * 原子更新基本类型
>  * * 原子更新数组
>  * * 原子更新对象
>  * * 原子更新对象字段（字段必须public 和 volatile）
>  
>           实现原理
>           1.使用了CAS算法来保证原子性，在语言层次我们是没有做任何关于同步的操作的，也没有任何锁。
>           2.Atomic包下这些类将这些操作都交给了CPU和内存，利用CPU多处理的能力，实现硬件的阻塞，
>           3.再加上volatile变量的特性即可实现基于原子性的操作的线程安全。所以CAS不是没有阻塞 ，只是阻塞不是语言层面，而是在硬件层面，这样便会更高效。
>
>           比较synchronized
>           1.synchronized是基于代码阻塞的机制，也就是当某个线程占用资源时，其他线程是无法进入的
>           2.如果中间线程出现问题的时候，出现大量线程阻塞，CPU就会耗费大量资源来处理阻塞在外的这些线程，
>           3.可能出现死锁等问题，对于这样的简单操作反而显得有些笨重
>           
>
# 锁的种类
> * 内置锁（隐式锁）
>
>       多线程的锁，其实本质上就是给一块内存空间的访问添加访问权限
>       因为Java中是没有办法直接对某一块内存进行操作的，又因为Java是面向对象的语言，一切皆对象，所以具体的表现就是某一个对象承担锁的功能，每一个对象都可以是一个锁。
>       内置锁使用方式就是使用 synchronized 关键字，synchronized 方法或者 synchronized 代码块。
>       加锁以及释放锁都交由jdk去管理，所以也被称为隐式锁

> * 互斥锁
>
>       当一个资源被线程1上了锁后，另外一个线程2就无法访问这个资源，必须等待线程1释放锁，称为互斥锁
>       也就是说当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制，线程同步能够保证多个线程安全访问竞争资源，就可以使用互斥锁
>
> * 重入锁
>
>       有方法A和方法B，这两个方法都加了锁，当一个线程从A开始调用，获得锁，然后开始调用B，这时如果可以进入B方法，就称这个锁是重入锁
> * 公平锁
> 
>           也就是说多个线程在获取同一个锁的顺序，和他们请求锁的顺序相同

# 锁的实现
> * 锁的实现无非两种，一种堵塞当前线程，一种是返回锁失败，中断当前线程，所以公平锁的实现就是基于阻塞当前线程的方式
