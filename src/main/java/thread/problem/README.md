# 活跃性问题
> `死锁` 
>
>       两个或多个线程永久阻塞，互相等待对方释放资源。

> `饥饿琐`（见live中案例）
>
>       1.优先级低的线程一直不能够被运行,活活被饿死 
>       2.高优先级吞噬所有低优先级的CPU时间片
>       3.线程被永久堵塞在一个等待进入同步块的状态 等待的线程永远不被唤醒
>
>         如何避免:
>             1.设置合理的优先级
>             2.使用琐代替synchronized, 来保证线程不会被永久的堵塞在一个等待进入的同步块

> `活锁` 
>
>       1.一个线程通常会有会响应其他线程的活动。
>       2.如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。
>       3.同死锁一样，发生活锁的线程无法继续执行。
>       4.然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。

> `性能问题` 
>
>       1.时间片由CPU分配给线程/进程,
>       每个时间片执行的时间结束,就会切换(需要记录上一次运行的记录),切换就会浪费资源所以性能不一定快

# 安全性问题
> `访问共享资源`
>
>       共享资源被多个线程访问，如果不加锁，会导致资源数据混乱
>       初始 a = 1;
>       线程1 执行 a = a + 1;
>       java虚拟机相当于执行 1 + 1；然后执行a = 2;
>       如果线程1执行到 1 + 1；的时候，线程2也去读a,此时a的值是1，然后执行1 + 1;a = 2;
>       这时到线程1执行a = 2;此时a连续加了两次，却值还是2，造成安全性问题
> 发生场景
> * 多线程共享资源 
> * 对资源进行非原子性操作(对应字节码中非一条运行就结束的操作) 
>
> 解决方案（加锁） 
> * synchronized 保证了在多线程共享资源时，对资源操作的原子性,但是一定要确认是给哪个对象加上了锁，是实例对象，还是当前的class对象，这很容易造成错误
>
> * synchronized 修饰实例方法
>
>       作用于当前实例加锁，进入同步代码前要获得当前实例的锁
>       当一个线程正在访问一个对象的 synchronized实例方法，那么其他线程不能访问该对象的其他synchronized方法，毕竟一个对象只有一把锁
>       原因:
>           当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法但是其他线程还是可以访问该实例对象的其他非synchronized方法 
>       案例：
>           当然如果是一个线程A需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)
>           另一个线程B需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的
>           原因:
>               因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，
>               遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了
>
>
>
# 锁的种类
> * 内置锁（隐式锁）
>
>       多线程的锁，其实本质上就是给一块内存空间的访问添加访问权限
>       因为Java中是没有办法直接对某一块内存进行操作的，又因为Java是面向对象的语言，一切皆对象，所以具体的表现就是某一个对象承担锁的功能，每一个对象都可以是一个锁。
>       内置锁使用方式就是使用 synchronized 关键字，synchronized 方法或者 synchronized 代码块。
>       加锁以及释放锁都交由jdk去管理，所以也被称为隐式锁

> * 互斥锁
>
>       当一个资源被线程1上了锁后，另外一个线程2就无法访问这个资源，必须等待线程1释放锁，称为互斥锁
>       也就是说当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制，线程同步能够保证多个线程安全访问竞争资源，就可以使用互斥锁





